---
layout: post
title: Git
---

## Tools

 * git-gui
 * gitk
 * Git Extensions

## Resources

 * [Git Immersion](http://gitimmersion.com) - GIT IMMERSION IS A GUIDED TOUR THAT WALKS THROUGH THE FUNDAMENTALS OF GIT, INSPIRED BY THE PREMISE THAT TO KNOW A THING IS TO DO IT.
 * [github:help](https://help.github.com)
 * [Pro Git](http://git-scm.com/book)
 * [Git Internals](http://git-scm.com/book/en/Git-Internals)


## SSH

Generate SSH Keys

    $ cd ~/.ssh
    $ ssh-keygen -t rsa -C "roger.xu.2007@gmail.com"
    # Creates a new ssh key, using the provided email as a label
    # Generating public/private rsa key pair.
    # Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]

    Your identification has been saved in /c/Users/you/.ssh/id_rsa.
    # Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.
    # The key fingerprint is:
    # 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com

Add SSH key to GitHub

    $ clip < ~/.ssh/id_rsa.pub
    # Copies the contents of the id_rsa.pub file to your clipboard

Add SSH public key to server

    $ cd ~
    $ mkdir .ssh
    $ chmod 700 ~/.ssh
    $ cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys
    $ chmod 600 ~/.ssh/authorized_keys
    $ cat ~/.ssh/authorized_keys

Test SSH

    $ ssh -T git@github.com
    # Attempts to ssh to github


## Configuration

    $ git config [Config file location] [Action]

Config file location

* `--system` - use system config file - `$GIT_HOME/etc/gitconfig`
* `--global` - use global config file - `$USER_HOME/.gitconfig`
* `--local` - use repository config file - `$git_repository/.git/config`
* `-f, --file <file>` - use given config file

### Set Configuration

    $ git config --local --list
    $ git config --local --edit
    $ git config --local --get http.proxy
    $ git config --get-all http.proxy
    $ git config --local http.proxy "http://localhost:8087"
    $ git config --local --unset http.proxy
    $ git config --local --unset-all http.proxy

### HTTP Proxy

Set the proxy for git at 'system' level (so that the 'jenkins' can read the config as well):

    $ git config --system http.proxy "http://localhost:8087"
    $ git config --system https.proxy "http://localhost:8087"
    $ git config --system http.sslVerify false
    $ git config --system --get http.proxy
    $ git config --get-all http.proxy

### Line Endings

`core.autocrlf`

* true - Checkout Windows-style, commit Unix-style line endings
* input - Checkout as-is, commit Unix-style line endings
* false - Checkout as-is, commit as-is

    $ git config --global core.autocrlf input


Using `text` attribute in [.gitattributes](http://www.kernel.org/pub/software/scm/git/docs/gitattributes.html) file in the root of the repository. This file overrides the `core.autocrlf` setting.

`text=auto`

This setting will tell git to handle the files specified automatically.

`text`

This setting tells git to always normalize the files specified. When committed they are stored with LF, on checkout they are converted to the OS's native line endings.

`text eol=crlf`

This setting tells git to normalize the files specified on commit, and always convert them to CRLF on checkout. You should use this for files that must retain CRLF endings.

`text eol=lf`

This setting tells git to normalize the files specified on commit, and always convert then to LF on checkout. You should use this for files that must retain LF endings.

`binary`

This setting tells git that the files specified are not text at all, and it should not try to change them. The `binary` setting

Example:

    # Set default behaviour, in case users don't have core.autocrlf set.
    * text=auto

    # Explicitly declare text files we want to always be normalized and converted
    # to native line endings on checkout.
    *.c text
    *.h text

    # Declare files that will always have LF line endings on checkout.
    *.sh text eol=lf

    # Declare files that will always have CRLF line endings on checkout.
    *.bat text eol=crlf
    *.ini text eol=crlf

    # Denote all files that are truly binary and should not be modified.
    *.png binary
    *.jpg binary
    *.gif binary
    *.bmp binary
    *.ico binary

### Change URL

* `url.<base>.insteadOf`

    $ git config --global url.https://github.com/.insteadOf git://github.com/


## Clone Repository

    $ git clone https://github.com/rogerxu/rogerxu.github.com.git
    $ cd rogerxu.github.com
    $ git remote -v
    $ git remote set-url origin https://rogerxu@github.com/rogerxu/rogerxu.github.com
    $ git fetch origin
    $ git hist --all
    $ git merge origin/master

## Commit Change

    $ git add --all .
    $ git status
    $ git diff
    $ git commit -m "Add files."
    $ git commit --amend --reset-author


### Storage Efficiency

Git does not store file deltas. Although you added only a single line to the end of a file, Git stored that new content as a completely new object. You have two nearly identical 4K objects on your disk. The initial format in which Git saves objects on disk is called a loose object format. However, occasionally Git packs up several of these objects into a single binary file called a packfile in order to save space and be more efficient. Git does this if you have too many loose objects around, if you run the git gc command manually, or if you push to a remote server.

When a new object (e.g. a file with previously unseen contents) enters the system, it is stored with plain (zlib) compression as a “loose object”. When enough loose objects accumulate (based on the gc.auto configuration option; or when the user runs git gc or one of the lower-level packing commands), Git will collect many loose objects into a single “pack file”.

Objects in a pack file can be stored either as plain compressed data (same as a loose object, just bundled up with others objects), or as compressed deltas against some other object. Deltas can be chained together to configurable depths (pack.depth) and are can be made against any suitable object (pack.window controls how widely Git searches for the best delta base; a version of an historically unrelated file can be used as a base if doing so would yield a good delta compression). The latitude that the depth and window size configurations give the delta compression engine often result in a better delta compression than the CVS-style simple one-version-against-the-next/previous-version “diff” compression.

It is this aggressive delta compression (combined with normal zlib compression) that can often let a Git repository (with full history and an uncompressed working tree) take less space than a single SVN checkout (with uncompressed working tree and pristine copy).


## Push Change

Syntax: `git push <repository> <refspec>`

    $ git push origin master:master

* `<refspec>` - The format is the source ref `<src>`, followed by a colon `:`, followed by the destination ref `<dst>`. -- `<src>:<dst>`

The `<src>` is often the name of the branch you would want to push.

The `<dst>` tells which ref on the remote side is updated with this push. If `:<dst>` is omitted, the same ref as `<src>` will be updated.

    $ git push origin master

Gerrit push:

    $ git push origin HEAD:refs/for/master


## Shared Repository

Create a bare repository

    $ cd ~
    $ git init --bare --shared=all foo.git
    $ chgrp -R dev foo.git


Clone git repository

    $ git clone ssh://git@localhost/~/foo.git foo

## Submodule

### Add a submodule

    $ git submodule add https://github.com/getify/LABjs.git src/main/webapp/vendor/LABjs

There will be a `.gitsubmodule` file stores info about the parent git and submodule git.

    [submodule "src/main/webapp/vendor/LABjs"]
        path = src/main/webapp/vendor/LABjs
        url = https://github.com/getify/LABjs.git

Commit this change.

    $ git status
    # On branch master
    # Changes to be committed:
    #   (use "git reset HEAD ..." to unstage)
    #
    #       new file:   .gitmodules
    #       new file:   src/main/webapp/vendor/LABjs
    #

    $ git add .gitmodules src/main/webapp/vendor/LABjs
    $ git commit -m "Add submodule into version control"

Initialize the submodules, i.e. register each submodule name and url found in `.gitmodules` into `.git/config`.

    $ git submodule init

### List submodule

    $ git submodule

### Update submodule

Update the registered submodules, i.e. clone missing submodules and checkout the commit specified in the index of the containing repository.

    $ git submodule update --init --recursive

Pull changes for each submodule.

    $ git submodule foreach git pull

Commit submodule changes.

    $ git add src/main/webapp/vendor/LABjs
    $ git commit -m "Update a submodule"

### Remove submodule

    $ git rm --cached src/main/webapp/vendor/LABjs
    $ rm -rf .git/modules/src/main/webapp/vendor/LABjs
    $ rm -rf src/main/webapp/vendor/LABjs
    $ vim .gitmodules
    $ vim .git/config

    $ git add .gitmodules
    $ git commit -m "Remove a submodule"
    $ git submodule sync

## Hooks

Like many other Version Control Systems, Git has a way to fire off custom scripts when certain important actions occur. There are two groups of these hooks: client side and server side. The client-side hooks are for client operations such as committing and merging. The server-side hooks are for Git server operations such as receiving pushed commits.

### Installing a Hook

The hooks are all stored in the `hooks` subdirectory of the Git directory. In most projects, that's `.git/hooks`.

To enable a hook script, put a file in the `hooks` subdirectory of your Git directory that is named appropriately and is executable. From that point forward, it should be called.

### Push notification from repository

To minimize the delay between a push and a build, it is recommended to set up the `post-receive` hook in the repository to poke Jenkins when a new commit is made. To do this, add the following line in your `hooks/post-receive` where "URL of the Git repository" is the fully URL you use to clone this repository.

    curl http://yourserver/jenkins/git/notifyCommit?url=<URL of the Git repository>[&branches=branch1[,branch2]*]


Edit `repository.git/hooks/post-receive`

    #!/bin/sh
    # Push notification from repository to poke Jenkins when a new commit is made.

    curl http://localhost:8080/jenkins/git/notifyCommit?url=ssh://git@localhost/~/app-web.git

And change the mode for `post-receive` script to make it executable.

    $ chmod 775 post-receive

This will scan all the jobs that's configured to check out the specified URL, the optional branches, and if they are also configured with polling, it'll immediately trigger the polling (and if that finds a change worth a build, a build will be triggered in turn.) We require the polling configuration on the job so that we only trigger jobs that are supposed to be kicked from changes in the source tree.

This allows a script to remain the same when jobs come and go in Jenkins. Or if you have multiple repositories under a single repository host application (such as Gitosis), you can share a single post-receive hook script with all the repositories. Finally, this URL doesn't require authentication even for secured Jenkins, because the server doesn't directly use anything that the client is sending. It runs polling to verify that there is a change, before it actually starts a build.

When successful, this will return the list of projects that it triggered polling as a response.


# Gerrit

## Best Practices

1. Create a new feature branch for each new feature and bug-fix (delete the local `master` branch).
2. Take always `origin/master` as basis to create new feature branch.
3. Always do a fetch before you create a new feature branch.
4. Generate a Chang-ID for every new commit.
5. Always write into the commit message why the changes are done (not what is done).
6. Avoid dependencies on changes that have not been submitted yet.
7. Never rewrite a commit that has already been submitted in the central repository.
8. When working with Gerrit favor rebase over merge to resolve path conflicts (that avoids extra merge commits).
9. Do not version jar files in your git repository, store them on Nexus.


## Migrate an exsiting git repository to Gerrit

### Access Control in Gerrit

- `refs/*`
  - Owner
    - `project_owners`
  - Forge Committer Identity
    - `project_integrators`

- `refs/heads/*`
  - Create Reference
    - `project_integrators`
  - Push
    - `project_integrators`
    - `project_owners`, Force Push
  - Label Code-Review
    - `project_committers` - -2 to +2
  - Label Verified
    - `project_committers` - -1 to +1
  - Submit
    - `project_committers`

### Rewrite branch commits

Use `filter-branch` command to rewrites all commits in current branch to match the provided user and update tags accordingly.

    $ git filter-branch --env-filter 'GIT_COMMITTER_NAME="Roger Xu"; GIT_COMMITTER_EMAIL="joe.test@test.org";'

### Push to Gerrit repository

Configure the remote `origin` and push all branches of your local repository to the server.

    $ git config remote.origin.url ssh://userid@github.com:29418/path/to/repo.git

    $ git push origin master:master
    $ git push origin rel-1.0:rel-1.0


### Delete remote branch

[Deleting your master branch](http://matthew-brett.github.io/pydagogue/gh_delete_master.html)

Create a new local branch and delete local `master` branch

    $ git branch placeholder
    $ git checkout placeholder
    $ git branch -D master

Delete remote `master` branch

    $ git push origin --delete master

Got error

    remote: error: By default, deleting the current branch is denied, because the next

    remote: error: 'git clone' won't result in any file checked out,
    causing confusion.
    remote: error:
    remote: error: You can set 'receive.denyDeleteCurrent' configuration variable to
    remote: error: 'warn' or 'ignore' in the remote repository to allow deleting the
    remote: error: current branch, with or without a warning message.
    remote: error:
    remote: error: To squelch this message, you can set it to 'refuse'.
    remote: error: refusing to delete the current branch: refs/heads/master
    To ssh://server_name/git/repository.git
    ! [remote rejected] master (deletion of the current branch prohibited)
    error: failed to push some refs to 'ssh://server_name/git/repository.git'

Set git config on remote repository

    $ git config --local receive.denyDeleteCurrent warn


## Code Review

### Doing a Code Review - Best Practices

Thing on which a reviewer should comment include:

* bugs / incorrect code
* usability issues
* performance issues
* bad code structure / bad design
* formatting issues / spelling mistakes
* code which is difficult to maintain
* unnecessary or unrelated code changes
* the commit message if it's not saying what the feature is about and what the motivation for it was
* existing code which still has to be adapted for the proposed feature

In addition a reviewer might
* provide own ideas related to the proposed feature
* ask questions about unclear code
* ask questions about the motivation for certain changes
* list reasons againstthe proposed feature
* propose to split the change if it addresses serveral issues at once

Doing a Code Review is not only about reviewing the code changes in the sense of just looking at them, but ideally you should also download the change and try out the proposed feature. For all issues that you find while trying out a feature you should try to find the corresponding code and comment there.

### Voting on a change - Best Practices

1. Voting in the Code Review category:

The voting in the Code Review category is to express a formal opinion about the code change based on a Code Review. In working practice even for minor issues (e.g. spelling mistake, errors with whitespaces) the '-1 I would prefer that you didn't submit this' is often used. This means the `-1` in the Code Review category should not be considered as something bad, but can often be understood like good change with some minor issues.

2. Voting in the Verified category:

The Verified category is for voting whether the code compiles and all unit tests pass successfully. Within our project it is recommended to setup a Jenkins job that automatically builds and tests each change pushed to Gerrit and that then does the voting in the Verified category based on the build result.

## Fetching a Change from Gerrit to Your Local Git Repository

Sometimes you may want to fetch a change, made by somebody else, from Gerrit to your local Git repository.

* you want to build and test the change
* the original author is on holidays and you want to fix some issues found in this change without waiting for the author
* you want to develop another feature that will have a dependency on the feature contained in the fetched change

The term change is Gerrit terminology. In Gerrit a change consists of:

* one or more patch-sets
* other data like: owner, comments, etc...

A patch-set is actually a Git branch containing a Git commit. It means fetching a remote branch that represents that patch-set.

fetch & checkout

    $ git fetch ssh://xxx@gerrit.corp:29418/sandbox/demo.repo refs/changes/91/53891/1 && git checkout FETCH_HEAD

The `fetch` command didn't create any local branch, it only brought the commit containing the change to the local repository and set the symbolic reference `FETCH_HEAD` to point to that commit. Therefore, we use the `FETCH_HEAD` as the parameter for `checkout` command.

Since `FETCH_HEAD` wasn't pointing to any local branch, the `checkout` command has informed us that after the checkout, `HEAD` is not on any branch. While this is a perfectly valid scenario you have to keep in mind that, if you want to perform further changes based on the fetched change you need to create a local branch based on `FETCH_HEAD` and check it out.

    $ git branch continue-feature-1 FETCH_HEAD
    $ git checkout continue-feature-1


## Share unfinished changes with other users

There are several possibilities to share unfinished changes with other users

1. upload your commit for code review and mark the change as RFC (request for comments)
  * mark your change as RFC by adding the prefix 'RFC:' in front of the title line in the commit change.
  * you may give a negative vote on your own change to prevent an accidental submit of your unfinished change
  * other users can comment on your unfinished change and fetch it from Gerrit

2. upload your commit to your sandbox

3. export your commit as patch and send the patch file to the other user
  * to create a patch file use the `git format-patch` command
  * to apply a patch file use the `git apply` command

4. directly push your commit to the repository of another user
  * for this you need to have direct access to the other users repository


# Git Workflow

## Centralized Workflow

## Feature Branch Workflow

## Gitflow Workflow

## Fork Workflow

### Fork

### Pull Request

base branch - where you think changes should be applied
head branch - what you would like to be applied


# Commit Strategy

### Small change

Merge to master and push to gerrit master

### Local sharing change

Create local branch issue-1

share his repository as roger/issue-1
push to draft repository draft/issue-1

### Feature branch

origin/poc


