---
layout: post
title: UI5
---

# Installation

# General Information

## Browser Support

## Security Information

# Development

## Coding Guidelines

* [JavaScript Coding Guidelines](http://vesapui5.dhcp.wdf.sap.corp:1080/trac/sapui5/wiki/InternalDocumentation/DevelopmentGuidelines/JavaScript)
* [Code Review Results](http://vesapui5.dhcp.wdf.sap.corp:1080/trac/sapui5/wiki/InternalDocumentation/DevelopmentGuidelines/CodeReviewResults)

## Initializing & Loading

### Bootstrapping

[Bootstrap](http://vesapui5.dhcp.wdf.sap.corp:1080/trac/sapui5/wiki/Documentation/AdvancedTopics/Bootstrap)

* sap-ui-core.js - jQuery, jquery-ui-position, minimal UI5 core
* sap-ui-core-nojQuery.js - minimal UI5 core
* sap-ui-core-all.js - single js file for each library
* sap-ui5.js - all-in-one file that contains all JS modules from the core, commons, table and ux3 libraries.

The `<script>` tag inside `<head>`:

    <script
        id="sap-ui-bootstrap"
        src="resources/sap-ui-core-all.js"
        data-sap-ui-noConflict="true"
        data-sap-ui-theme="sap_goldreflection
        data-sap-ui-libs="sap.ui.commons">
    </script>


### Configuration

## Control API

### Layout

`layoutData` - LayoutData defining the layout constraints for this control when it is used inside a Layout.

#### sap.ui.layout.HorizontalLayout

A layout that provides support for horizontal alignment of controls.

    <layout:HorizontalLayout id="layout" allowWrapping="false">
        <TextView text="1"></TextView>
        <TextView text="2"></TextView>
    </layout:HorizontalLayout>


#### sap.ui.layout.VerticalLayout

In this layout the elements are ordered one below the other.

    <layout:VerticalLayout id="layout" width="100%" enabled="true">
        <TextView text="1"></TextView>
        <TextView text="2"></TextView>
    </layout:VerticalLayout>


#### sap.ui.layout.Grid

The Grid control is a layout which positions its child controls in a 12 column flow layout.

With this control it is possible to achieve flexible layouts and line-breaks for large-, medium- and small-sized screens, such as desktop, tablet, and mobile.

Layout - `sap.ui.layout.Grid`
* `hSpacing` - Horizontal spacing between the content in the Grid. In rem, can be 0, 1 or 2.
* `vSpacing` - Vertical spacing between the rows in the Grid. In rem, can be 0, 1 or 2.

LayoutData - `sap.ui.layout.GridData`
* `indent` - represents Grid's indent values for large, medium and small screens.
* `span` - represents Grid's span values for large, medium and small screens.

```
    <layout:Grid id="layout" hSpacing="1" vSpacing="1">
        <TextView text="Indent by 3 columns on large, 2 columns on medium, and 1 column on small screens.">
            <layoutData>
                <layout:GridData indent="L3 M2 S1" span="L2 M2 S2"></layout:GridData>
            </layoutData>
        </TextView>
        <TextView text="Indent by 1 column on large, 2 columns on medium, and 3 column on small screens.">
            <layoutData>
                <layout:GridData indent="L1 M2 S3" span="L2 M2 S2"></layout:GridData>
            </layoutData>
        </TextView>
    </layout:Grid>
```


#### sap.ui.layout.ResponsiveFlowLayout

With ResponsiveFlowLayout added content can be expanded to the full width of a row.

The default HTML behavior is that all items are positioned right next to each other. If the space within the parent container becomes too small, the browser wraps the corresponding item to the next line. In this case the space within a line isn't used.

With this layout each added content can be shrinked to a set min-width. So the layout shrinks it until this set value and wraps it if necessary. Each content within a line will be maximized to fit the whole line. Each content item can have a weight corresponding to other items within a line. If one item has the weight of '2' and all others have '1' so this single item will always be twice of all others.

* `responsive` - If this property is 'false' all added controls keep their widths. Otherwise all added controls will be extended to the possible width of a row.

LayoutData - `sap.ui.layout.ResponsiveFlowLayoutData`

A LayoutData instance can be added to a control that should be used within the ResponsiveFlowLayout. With this instance other values than the default values can be used.

Default values are:

* `minWidth`: 100 - that means that the min-width is used as "100px".
* `weight`: 1 - the weight of the added content item. A value smaller than 1 is not valid.
* `linebreak`: false - this content item won't be at the first position of a row. Otherwise this item will always be first in a line.
* `margin`: true - this property prevents any margin of the element if set to false.
* `linebreakable`: true - If this value is set to true, the element can be wrapped into a new line. If this value is set to false, the min-width will be set to 0 and the wrapping is up to the previous element.

In this case the Label and the TextField belong together. If the space becomes too less the TextField is wrapped below the Label. If the space is continuing shrinking, the part of the 'Last name' is wrapped below the 'First name' stuff.

    <layout:ResponsiveFlowLayout id="layout">

        <layout:ResponsiveFlowLayout id="innerFirst">
            <layout:layoutData>
                <layout:ResponsiveFlowLayoutData minWidth="250"></layout:ResponsiveFlowLayoutData>
            </layout:layoutData>

            <Label text="First name" width="100%"></Label>
            <TextField width="100%">
                <layoutData>
                    <layout:ResponsiveFlowLayoutData weight="2"></layout:ResponsiveFlowLayoutData>
                </layoutData>
            </TextField>
        </layout:ResponsiveFlowLayout>

        <layout:ResponsiveFlowLayout id="innerLast">
            <layout:layoutData>
                <layout:ResponsiveFlowLayoutData minWidth="250"></layout:ResponsiveFlowLayoutData>
            </layout:layoutData>

            <Label text="Last name" width="100%"></Label>
            <TextField width="100%">
                <layoutData>
                    <layout:ResponsiveFlowLayoutData weight="2"></layout:ResponsiveFlowLayoutData>
                </layoutData>
            </TextField>
        </layout:ResponsiveFlowLayout>

    </layout:ResponsiveFlowLayout>

### Form

#### sap.ui.layout.form.SimpleForm

Use the SimpleForm to create a form based on title, label and fields that are stacked in the content aggregation. Add Title to start a new FormContainer (Group). Add Label to start a new row in the container. Add Input/Display controls as needed. Use LayoutData to influence the layout for special cases in the Input/Display controls.

#### sap.ui.layout.form.GridLayout

The GridLayout can be attached to the Form Control in order to arrange the Elements in a cell based Layout.

To adjust the content inside the GridLayout GridContainerData and GridElementData could be used.

This layout implements a guideline 2.0 grid. this can be a 16 column grid or an 8 column grid.

The GridLayout is by default a 16 cells grid but you can set the `singleColumn` property to `true` in order to get an 8 cell grid. In this case you cannot include halfGrid Containers. Within the default Grid the FormContainers you can also place two containers in one row by setting `halfGrid` to `true` within the respective GridContainerData attached. The FormElements included can then have `hCells` and `vCells` set as GridElementData attached to the respective labels and fields in order to get the different arrangements within the grid. You can also add dummy FormElements in order to get some spare rows or dummy TextViews in order to get some spare cells.

* `singleColumn` - default `false`

Label is 3 cells by default. Field is 13 cells by default.

    <form:Form>
        <form:layout>
            <form:GridLayout singleColumn="false"></form:GridLayout>
        </form:layout>

        <form:FormContainer title="Legend">
            <form:layoutData>
                <form:GridContainerData halfGrid="false"></form:GridContainerData>
            </form:layoutData>

            <form:FormElement label="Email">
                <TextField name="email" placeholder="Email"></TextField>
            </form:FormElement>
            <form:FormElement label="Password">
                <PasswordField name="password" placeholder="Password"></PasswordField>
            </form:FormElement>
            <form:FormElement label="">
                <CheckBox name="checked" text="Checkbox"></CheckBox>
            </form:FormElement>
            <form:FormElement label="Radios">
                <RadioButtonGroup name="option">
                    <core:Item key="1" text="Option one is this"></core:Item>
                    <core:Item key="2" text="Option two can be something else"></core:Item>
                </RadioButtonGroup>
            </form:FormElement>
            <form:FormElement label="">
                <ListBox>
                    <core:ListItem key="1" text="Item 1"></core:ListItem>
                    <core:ListItem key="2" text="Item 2"></core:ListItem>
                    <core:ListItem key="3" text="Item 3"></core:ListItem>
                    <core:ListItem key="4" text="Item 4"></core:ListItem>
                    <core:ListItem key="5" text="Item 5"></core:ListItem>
                </ListBox>
            </form:FormElement>
            <form:FormElement label="">
                <Button text="Cancel">
                    <layoutData>
                        <form:GridElementData hCells="2"></form:GridElementData>
                    </layoutData>
                </Button>
                <Button text="Submit" style="Emph">
                    <layoutData>
                        <form:GridElementData hCells="2"></form:GridElementData>
                    </layoutData>
                </Button>
            </form:FormElement>
        </form:FormContainer>
    </form:Form>

#### sap.ui.layout.form.ResponsiveLayout

Render a form with responsive layout. Internally the ResponsiveFlowLayout is used.

You can use `ResponsiveFlowLayoutData` on FormContainers, FormElements and the content controls like in the ResponsiveFlowLayout control. so it is possible to influence the linebreaks, min width and weights of the single elements. If you use `ResponsiveFlowLayoutData` on Containers or Elements you should disable the margins to avoid nested margins. If `ResponsiveFlowLayoutData` are used, the margins are disabled by default.


    <form:Form>
        <form:layout>
            <form:ResponsiveLayout></form:ResponsiveLayout>
        </form:layout>

        <form:FormContainer title="Legend">
            <form:FormElement label="Email">
                <TextField name="email" placeholder="Email"></TextField>
            </form:FormElement>
            <form:FormElement label="Password">
                <form:layoutData>
                    <layout:ResponsiveFlowLayoutData linebreak="true" margin="false"></layout:ResponsiveFlowLayoutData>
                </form:layoutData>
                <PasswordField name="password" placeholder="Password"></PasswordField>
            </form:FormElement>
        </form:FormContainer>

        <form:FormContainer title="Legend 2">
            <form:FormElement label="">
                <CheckBox name="checked" text="Checkbox"></CheckBox>
            </form:FormElement>
            <form:FormElement label="Radios">
                <RadioButtonGroup name="option">
                    <layoutData>
                        <layout:ResponsiveFlowLayoutData weight="2"></layout:ResponsiveFlowLayoutData>
                    </layoutData>
                    <core:Item key="1" text="Option one is this"></core:Item>
                    <core:Item key="2" text="Option two can be something else"></core:Item>
                </RadioButtonGroup>
            </form:FormElement>
            <form:FormElement label="">
                <Button text="Cancel">
                    <layoutData>
                        <layout:ResponsiveFlowLayoutData weight="1"></layout:ResponsiveFlowLayoutData>
                    </layoutData>
                </Button>
                <Button text="Submit" style="Emph">
                    <layoutData>
                        <layout:ResponsiveFlowLayoutData weight="1"></layout:ResponsiveFlowLayoutData>
                    </layoutData>
                </Button>
            </form:FormElement>
        </form:FormContainer>
    </form:Form>


#### sap.ui.layout.form.ResponsiveGridLayout

Render a form using a grid. Internally the Grid is used. On the FormContainers, Labels and Fields GridData can be used to change the default rendering. On FormElements GridData are not supported. If own GridData are used this may be much more complex than the default. So in some cases the calculation for the other content may nor bring the expected result. In this case GridData should be used at all content to disable the default behavior.

You can use `GridData` on FormContainers and the content controls like in the Grid control. On FormElements `GridData` are not supported. To influence the rendering of the labels and fields `GridData` must be set on these controls. If no `GridData` are used on a FormContainer or Control, the `ResponsiveGridLayout` tries to calculate the linebreaks and spans.

    <form:Form>
        <form:layout>
            <form:ResponsiveGridLayout></form:ResponsiveGridLayout>
        </form:layout>

        <form:FormContainer title="Legend">
            <form:FormElement label="Email">
                <TextField name="email" placeholder="Email"></TextField>
            </form:FormElement>
            <form:FormElement label="Password">
                <PasswordField name="password" placeholder="Password"></PasswordField>
            </form:FormElement>
        </form:FormContainer>

        <form:FormContainer title="Legend 2">
            <form:FormElement label="">
                <CheckBox name="checked" text="Checkbox"></CheckBox>
            </form:FormElement>
            <form:FormElement label="Radios">
                <RadioButtonGroup name="option">
                    <layoutData>
                        <layout:GridData span="L2 M2 S12"></layout:GridData>
                    </layoutData>
                    <core:Item key="1" text="Option one is this"></core:Item>
                    <core:Item key="2" text="Option two can be something else"></core:Item>
                </RadioButtonGroup>
            </form:FormElement>
            <form:FormElement label="">
                <Button text="Cancel">
                    <layoutData>
                        <layout:GridData span="L2 M2 S6"></layout:GridData>
                    </layoutData>
                </Button>
                <Button text="Submit" style="Emph">
                    <layoutData>
                        <layout:GridData span="L2 M2 S6"></layout:GridData>
                    </layoutData>
                </Button>
            </form:FormElement>
        </form:FormContainer>
    </form:Form>


## Data Binding

    // JSON sample data
    var data = {
        firstName: "John",
        lastName: "Doe",
        birthday: {day: 01, month: 05, year: 1982},
        address: [{city: "Heidelberg"}],
        enabled: true
    };

    // create JSON model instance
    var model = new sap.ui.model.json.JSONModel();
    // set the data for the model
    model.setData(data);
    // set the model to the core
    sap.ui.getCore().setModel(model);

### Context

CHANGE in VERSION 1.5.1 (MAY 2012): Databinding syntax changed, so that absolute bindings now must have a leading slash. For compatibility reasons, method `setLegacySyntax()` can be used to enable the old binding syntax.

Absolute path - with a leading slash

    var id = model.getProperty("/id");

Relative path - no leading slash and with a context instance:

    var context = new sap.ui.model.Context(model, "/users/0");
    var id = model.getProperty("id", context);

### Data Type

### Validation

## MVC

### Concept

### Fragments

Fragments are pieces of UI - just like SAPUI5 MVC Views, but without the View Control around the content and without their own Controller.

Fragments are light-weight UI parts (UI sub-trees) which can be re-used, defined similar to Views, but do not have any controller or other behavior code involved. They support re-use and View modularization without adding overhead.

Fragments are defined (like Views) within a separate File. The file name ends with `*.fragment.*`.

`ui/fragment/SampleUiPart.fragment.xml`:

    <Panel xmlns="sap.ui.commons">
        <Button id="btnInFragment" text="Hello World" press="doSomething"></Button>
    </Panel>

Instantiating XML Fragments programmatically:

    var panel = sap.ui.xmlfragment("ui.fragment.SampleUiPart"); // this specific fragment does not need a Controller.

Instantiating Fragments in declarative Views:

    <mvc:View controllerName="ui.view.FragmentSample"
        xmlns="sap.ui.commons"
        xmlns:core="sap.ui.core"
        xmlns:mvc="sap.ui.core.mvc"
        xmlns:layout="sap.ui.layout"
        xmlns:form="sap.ui.layout.form">
        <core:Fragment id="fragment1" fragmentName="ui.fragment.SampleUiPart" type="XML" />
    </mvc:View>

One important  difference to Views is that Fragments are no Controls. Views *contain* their content Controls, Fragments *consist* of their content Controls.

And ID can be optionally given. If no ID is given, any Control IDs specified in the Fragment are used as-is. If a Fragment is used several times this can lead to duplicated IDs. One way to avoid that problem is to specify a Fragment ID. This ID will then be used as prefix for all Controls in this Fragment instance.

#### Dialogs as Fragments

Fragments are suited to declaratively define Dialogs and other Popup controls which are not part of the normal page UI structure. This is a huge advantage over Views which do not support this usage (basically because the View Control is always a wrapper around the View content).

To use Fragments for defining popups, just let the root Control of the Fragment be a Dialog or similar control.

#### Unique IDs

Fragments are meant to be a more light-weight concept of separating and re-using UI parts. Therefore static IDs in Fragments are by default used as-is, i.e. they are NOT prefixed to make them unique. But when a Fragment is supposed to be used serveral times within one application, the prefixing mechanism can still be used, by giving and ID when instantiating the Fragment.

When the Fragment is NOT part of a View:

    var control = sap.ui.core.Fragment.byId("myFrag", "myControl");

When the Fragment is embedded into a View and the code is inside a Controller:

    var control = this.byId(sap.ui.core.Fragment.createId("myFrag", "myControl"));

### Model Inheritance

    init: function(isStandalone) {
        if (isStandalone) {
            this.initModel();
        }

        this.initBinding();
        this.initSubView();
    }

## Localization

* Java message bundle \*.properties
* Switch locales by setting different resource bundles.
* Cannot support parameters well.

    var format = {style: "medium"}; // "short", "medium", "long", "full"
    var locale = new sap.ui.core.Locale("en-US");
    var dateFormat = sap.ui.core.format.DateFormat.getDateTimeInstance(format, locale);
    var str = dateFormat.format(new Date());

Date time formats in v1.8.7:

    || Format || en-US || en-GB || zh-CN || zh-TW ||
    | dateFormat-full | Tuesday, January 15, 2013 | Tuesday, 15 January 2013 | 2013年1月15日星期二 | 2013年1月15日星期二 |
    | dateFormat-long | January 15, 2013 | 15 January 2013 | 2013年1月15日 | 2013年1月15日 |
    | dateFormat-medium | Jan 15, 2013 | 15 Jan 2013 | 2013-1-15 | 2013/1/15 |
    | dateFormat-short | 1/15/13 | 15/01/2013 | 13-1-15 | 13/1/15 |
    | timeFormat-full | 7:09:08 PM GMT+08:00 | 19:09:08 GMT+08:00 | GMT+08:00下午7时09分08秒 | GMT+08:00下午7時09分08秒 |
    | timeFormat-long | 7:09:08 PM GMT+08:00 | 19:09:08 GMT+08:00 | GMT+08:00下午7时09分08秒 | GMT+08:00下午7時09分08秒 |
    | timeFormat-medium | 7:09:08 PM | 19:09:08 | 下午7:09:08 | 下午7:09:08 |
    | timeFormat-short | 7:09 PM | 19:09 | 下午7:09 | 下午7:09 |
    | dateTimeFormat-full | Tuesday, January 15, 2013 7:09:08 PM GMT+08:00 | Tuesday, 15 January 2013 19:09:08 GMT+08:00 | 2013年1月15日星期二GMT+08:00下午7时09分08秒 | 2013年1月15日星期二GMT+08:00下午7時09分08秒 |
    | dateTimeFormat-long | January 15, 2013 7:09:08 PM GMT+08:00 | 15 January 2013 19:09:08 GMT+08:00 | 2013年1月15日GMT+08:00下午7时09分08秒 | 2013年1月15日GMT+08:00下午7時09分08秒 |
    | dateTimeFormat-medium | Jan 15, 2013 7:09:08 PM | 15 Jan 2013 19:09:08 | 2013-1-15 下午7:09:08 | 2013/1/15 下午7:09:08 |
    | dateTimeFormat-short | 1/15/13 7:09 PM | 15/01/2013 19:09 | 13-1-15 下午7:09 | 13/1/15 下午7:09 |


## Control Development

[File structure of SAPUI5 UI libraries](http://vesapui5.dhcp.wdf.sap.corp:1080/trac/sapui5/wiki/Documentation/AdvancedTopics/FileStructure)

The specific fold structure:

    src/main/uilib
        |-- <library-folder>
            |-- themes
                |-- base                // one 'theme' that can be loaded at runtime... base is mandatory
                    |-- library.css
                |-- sap_goldreflection
                    |-- library.css
                |-- sap_hcb
                    |-- library.css
            |-- library.js
            |-- shared.js               // containing 'shared' javascript like datatypes etc.
            |-- <Control>.js            // containing the control API and implementation
            |-- <Control>Renderer.js    // containing the renderer for the control
    src/test/uilib
        |-- test-resources
            |-- <libraryName>
                |-- <Control>.html


## Modularization

[Modularization and Dependency Management](http://vesapui5.dhcp.wdf.sap.corp:1080/trac/sapui5/wiki/Documentation/AdvancedTopics/ModularizationConcept)

## Resource Handling

### Client-Side Mechanism

### Server-Side Mechanism

#### Resource Servlet

    <!-- ============================================================== -->
    <!-- SAPUI5 resource servlet used to handle application resources   -->
    <!-- ============================================================== -->

    <servlet>
        <display-name>ResourceServlet</display-name>
        <servlet-name>ResourceServlet</servlet-name>
        <servlet-class>com.sap.ui5.resource.ResourceServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>ResourceServlet</servlet-name>
        <url-pattern>/resources/*</url-pattern>
    </servlet-mapping>
    <servlet-mapping>
        <servlet-name>ResourceServlet</servlet-name>
        <url-pattern>/test-resources/*</url-pattern>
    </servlet-mapping>

##### Configuration

The Resource Handler is configured via context parameter which are defined in the web.xml.

* `com.sap.ui5.resource.USE_CACHE` - flag to enable resource cache or not (default: "true")
* `com.sap.ui5.resource.MAX_AGE` - max age of resources in millis (default: "604800000" - 1 week)
* `com.sap.ui5.resource.ACCEPTED_ORIGINS` - list of accepted origins, e.g. \* or \*sap.corp,vesapui5.dhcp.wdf.sap.corp (default: empty)
* `com.sap.ui5.resource.DEV_MODE` - flag to enable the development mode (default: "false")
* `com.sap.ui5.resource.TEMPLATE_PATH` - template for the resource listing (default: "/templates/listing.html")
* `com.sap.ui5.resource.VERBOSE` - verbosity of the resource handler (default: "false")
* `com.sap.ui5.resource.REMOTE_LOCATION` - remote location which is used to proxy requests to for resources not being located locally (default: empty)
* `com.sap.ui5.resource.PREFER_REMOTE_LOCATION` - flag to prefer resolving the resource from the remote location before fallback to the classpath (default: false)

##### Development Mode

When starting to develop SAPUI5 controls and modules being located inside the servlet paths resources/ or test-resources/ it makes simplifies this development process by disabling the caching of such resources as well as enabling the resource browsing. To activate the development mode you need to add the following context parameter.

    <!-- BEGIN: DEV MODE -->
    <context-param>
        <param-name>com.sap.ui5.resource.DEV_MODE</param-name>
        <param-value>true</param-value>
    </context-param>
    <!-- END: DEV MODE -->


## Cache Buster

A **Cache Buster** allows the application to notify the browser to refresh the resources only when the application resources have been changed. Otherwise the resources can always be fetched from the browser's cache.


## Theming


## Popup

### Hide in XML view


### DOM location

sap.ui.core.Popup - popups are placed in a static area.

    var core = sap.ui.core.getCore();
    var staticAreaRef = core.getStaticAreaRef();
    var $staticArea = jQuery(staticAreaRef);
    var $popups = $staticArea.children("class~=['sapUiUx3TP']");

### Dock, Position


# Testing

[Testing Environment](http://vesapui5.dhcp.wdf.sap.corp:1080/trac/sapui5/wiki/InternalDocumentation/TestingEnvironment)

## Selenium

[UI5 Control Wrapper for Selenium Application Testing](http://vesapui5.dhcp.wdf.sap.corp:1080/trac/sapui5/wiki/InternalDocumentation/TestingEnvironment/SeleniumWrapper)

[Selenium WebDriver Automation Framework](https://wiki.wdf.sap.corp/wiki/display/ECFQE/Selenium+WebDriver+Automation+Framework)

## QUnit

[How to Setup QUnit](http://vesapui5.dhcp.wdf.sap.corp:1080/trac/sapui5/wiki/InternalDocumentation/TestingEnvironment/HowToSetupQUnit)

UI5 implemented a bridge JSUnit to QUnit which is responsible to collect the status information of the QUnit tests and report them back into the JSUnit framework.

[QUnit Testing](http://vesapui5.dhcp.wdf.sap.corp:1080/trac/sapui5/wiki/Documentation/AdvancedTopics/QUnit)

#### Why does UI5 use Qunit tests?

QUnit tests have been proven to provide a much better support for asynchronous testing in comparision to JSUnit. These kind of tests are often needed for UI functional tests (e.g. wait until rendering is done, some animations complete or a backend call returns) but are complicated to create via JSUnit and are error-prone.

A QUnit test page can be executed standalone in the browser without the need of an additional "tool" like the JSUnit Testrunner. This eases the creation and execution of single QUnit tests.

Finally QUnit is closely related to jQuery (which is also included in UI5).

#### Why does UI5 use JSUnit Testrunner?

The JSUnit Testrunner can be easily integrated into the Maven build (Lean DI) environment to execute our JavaScript unit tests each build. The result of the Testrunner execution finally creates a report in the Maven surefire format which can be used for reporting purposes of a Hudson build server or a Sonar quality system or at least cause a Maven build to break. Also the JSUnit Testrunner is not using any JS shell (e.g. like Jasmine which is using Rhino) furthermore it opens a browser as a process with a parameter containing the site to load and finally waits until the browser submits the results to the Testrunner server. Another interesting usage of the JSUnit Testrunner is that you can cluster your tests in testsuites.

[How To Write A QUnit Test](http://vesapui5.dhcp.wdf.sap.corp:1080/trac/sapui5/wiki/InternalDocumentation/TestingEnvironment/QUnitHowToWriteQUnitTest)

## Build Integration

Inside the POM we use the antrunner plugin to execute the JSUnit TestRunner but beforehand we deploy the jsunit-tests and the jsunit-testrunner war files into a Jetty container. Afterwards it opens a browser with a specific URL and waits until the test has been executed and the result has been submitted to JSUnit server. Now the result will be converted into the Maven surefire format (JUnit). This result can be used e.g. in the Hudson build and display.
