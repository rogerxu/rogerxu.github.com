---
layout: post
title: UI5
---

## Installation

## Browser Support

### Libraries

* sap.ui.commons
* sap.m
* sap.me
* sap.makit
* sap.ui.ux3
* sap.viz


## Bootstrapping

[Bootstrap](http://vesapui5.dhcp.wdf.sap.corp:1080/trac/sapui5/wiki/Documentation/AdvancedTopics/Bootstrap)

* `sap-ui-core.js` - standard bootstrap file that contains jQuery, jquery-ui-position, minimal UI5 core. Required files are loaded dynamically using XMLHttpRequests (XHRs)
* `sap-ui-core-nojQuery.js` - minimal UI5 core, anything from jQuery is left out (jQuery & jquery-ui-position)
* `sap-ui-core-all.js` - single js file containing (nearly) all resources from the sap.ui.core library

The `<script>` tag inside `<head>`:

    <script
        id="sap-ui-bootstrap"
        src="resources/sap-ui-core-all.js"
        data-sap-ui-noConflict="true"
        data-sap-ui-libs="sap.ui.commons"
        data-sap-ui-theme="sap_bluecrystal">
    </script>


## Configuration

SAPUI5 provides the following options for providing configuration settings for SAPUI5 runtime:

* Runtime default values
* Individual script tag attributes
* Single and complex configuration attributes
* Global configuration object

    <script>
        window["sap-ui-config"] = {
            noConflict: true
        };
    </script>

* URL parameters

You can specify confiuration parameters by adding them as parameters to the start URL of an application. The name of the URL parameters is composed of the name of the configuration option and the `sap-ui-` prefix.

* Runtime configuration object

The above described options for configuration are all evaluated during SAPUI5 runtime boots. After that, all changes to these parameters are ignored. The final configuration result can be read by means of the `sap.ui.getCore().getConfiguration()` method.

The same object also provides set methods for a very limited set of configuration options. Such options can be modified at runtime and the runtime and/or the controls can react on the configuration changes. The most prominent (and so far only) example for such a configuration option is the theme.


### Configuration Options

* `accessibility`
* `animation`


## Component

It is an important structural aspect of SAPUI5.

```
-- sample
    |-- app
        |-- controller
            |-- App.controller.js
        |-- i18n
            |-- i18n.properties
        |--view
            |-- App.view.xml
        |-- Component.js
        |-- index.html
        |-- manifest.json
    |-- test
```

`manifest.json`

`Component.js`

```javascript
sap.ui.define([
    "sap/ui/core/UIComponent",
    "sap/ui/model/json/JSONModel",
    "sap/ui/model/resource/ResourceModel"
], function (UIComponent, JSONModel, ResourceModel) {
    "use strict";

    return UIComponent.extend("ui.demo.Component", {

        metadata: {
            manifest: "json"
        },

        /**
         * The component is initialized by UI5 automatically during the startup of the app and calls the init method once.
         * In this function, the resource and application models are set and the router is initialized.
         * @public
         * @override
         */
        init: function () {
            // call the base component's init function
            UIComponent.prototype.init.apply(this, arguments);

            // set data model
            var data = {
                version: {
                    sapui5: sap.ui.version
                }
            };

            var model = new JSONModel(data);
            this.setModel(model);

            // set i18n model on view
            var i18nModel = new ResourceModel({
                bundleName: "ui.demo.i18n.i18n"
            });
            this.setModel(i18nModel, "i18n");
        }
    });

}, /* bExport= */ true);
```

The Component.js file consists of two parts now: The **metadata** section that simply defines a reference to the descriptor and the **init** function that is called when the component is initialized.

In previous versions of SAPUI5, additional configuration settings for the app, like the service configuration, the root view, and the routing configuration, had to be added to the metadata section of the `Component.js` file . As of SAPUI5 version 1.30, we recommend to define these settings in the `manifest.json` descriptor file. Apps and examples that were created based on an older SAPUI5 version, still use the `Component.js` file for this purpose - so it is still supported, but not recommended.

`index.html`

```javascript
sap.ui.getCore().attachInit(function() {
    new sap.ui.core.ComponentContainer({
        name: "ui.demo",
        height: "100%"
    }).placeAt("content");
});
```

## MVC

### Models

SAPUI5 provides the following predefined models:

* The _JSON model_ can be used to bind controls to JavaScript object data, which is usually serialized in the JSON format. The JSON model is a client-side model and, therefore, intended for small datasets, which are completely available on the client. The JSON model supports two-way binding.
* The _XML model_ is a client-side model intended for small datasets, which are completely available on the client. The XMLModel does not contain mechanims for server-based paging or loading of deltas
* The _Resource model_ is designed to handle data in resource bundles, mainly to provide texts in different languages.
* The _OData model_ enables binding of controls to data from OData services. The OData model is a server-side model: the dataset is only available on the server and the client only knows the currently visible rows and fields.

### Views

SAPUI5 provides the following predefined view types

* _XML view_. The user interface is defined in an XML file or string.

```
<mvc:View controllerName="sap.hcm.Address" xmlns="sap.ui.commons" xmlns:core="sap.ui.core">
    <Panel>
        <Button text="Press Me!" />
    </Panel>
</mvc:View>
```

* _JSON view_. The user interface is defined in a file or string in JSON format.
* _JS view_. The user interface is constructed in a traditional manner.
* _HTML view_. The user interface is defined in an HTML file or string.

### Controllers

A controller in SAPUI5 is used to separate view logic from model logic. All methods for controlling the data flow should be implemented in a controller.

#### Controller Definition

You define a simple controller without functions as follows:

    sap.ui.controller("sap.hcm.Address", {
        // controller logic goes here
    });

The string in quotes specifies the controller name. The controller file is then named `Address.controller.js`.

#### Lifecycle Hooks

SAPUI5 provides predefined lifecycle hooks for implementation. You can add event handlers or other functions to the controller and the controller can fire events, for which other controllers or entities can register.

SAPUI5 provides the following lifecycle hooks:

* `onInit()`: Called when a view is instantiated and its controls (if available) have already been created; used to modify the view before it is displayed to bind event handlers and do other one-time initialization
* `onExit()`: Called when the view is destroyed; used to free resources and finalize activities
* `onAfterRendering()`: Called when the view has been rendered and, therefore, its HTML is part of the document; used to do post-rendering manipulations of the HTML. SAPUI5 controls get this hook after being rendered.
* `onBeforeRendering()`: Invoked before the controller view is re-rendered and not before the first rendering; use onInit() for invoking the hook before the first rendering

    sap.ui.controller("sap.hcm.Address", {
        onInit: function() {
            this.counter = 0;
        }
    });


### Fragments

Fragments are pieces of UI, just like SAPUI5 MVC views, but without the view control around the content and without their own controller.

Fragments are light-weight UI parts (UI sub-trees) which can be re-used, defined similar to Views, but do not have any controller or other behavior code involved. They support re-use and View modularization without adding overhead.

Fragments are defined (like Views) within a separate File. The file name ends with `*.fragment.*`.

`ui/fragment/SampleUiPart.fragment.xml`:

    <Panel xmlns="sap.ui.commons">
        <Button id="btnInFragment" text="Hello World" press="doSomething"></Button>
    </Panel>

Instantiating XML Fragments programmatically:

    var panel = sap.ui.xmlfragment("ui.fragment.SampleUiPart"); // this specific fragment does not need a Controller.

Instantiating Fragments in declarative Views:

    <mvc:View controllerName="ui.view.FragmentSample"
        xmlns="sap.ui.commons"
        xmlns:core="sap.ui.core"
        xmlns:mvc="sap.ui.core.mvc"
        xmlns:layout="sap.ui.layout"
        xmlns:form="sap.ui.layout.form">
        <core:Fragment id="fragment1" fragmentName="ui.fragment.SampleUiPart" type="XML" />
    </mvc:View>

One important  difference to Views is that Fragments are no Controls. Views *contain* their content Controls, Fragments *consist* of their content Controls.

And ID can be optionally given. If no ID is given, any Control IDs specified in the Fragment are used as-is. If a Fragment is used several times this can lead to duplicated IDs. One way to avoid that problem is to specify a Fragment ID. This ID will then be used as prefix for all Controls in this Fragment instance.

#### Dialogs as Fragments

Fragments are suited to declaratively define Dialogs and other Popup controls which are not part of the normal page UI structure. This is a huge advantage over Views which do not support this usage (basically because the View Control is always a wrapper around the View content).

To use Fragments for defining popups, just let the root Control of the Fragment be a Dialog or similar control.

#### Unique IDs

Fragments are meant to be a more light-weight concept of separating and re-using UI parts. Therefore static IDs in Fragments are by default used as-is, i.e. they are NOT prefixed to make them unique. But when a Fragment is supposed to be used serveral times within one application, the prefixing mechanism can still be used, by giving and ID when instantiating the Fragment.

When the Fragment is NOT part of a View:

    var control = sap.ui.core.Fragment.byId("myFrag", "myControl");

When the Fragment is embedded into a View and the code is inside a Controller:

    var control = this.byId(sap.ui.core.Fragment.createId("myFrag", "myControl"));

### Model Inheritance

    init: function(isStandalone) {
        if (isStandalone) {
            this.initModel();
        }

        this.initBinding();
        this.initSubView();
    }


## Data Binding

    // JSON sample data
    var data = {
        firstName: "John",
        lastName: "Doe",
        birthday: {day: 01, month: 05, year: 1982},
        address: [{city: "Heidelberg"}],
        enabled: true
    };

    // create JSON model instance
    var model = new sap.ui.model.json.JSONModel();
    // set the data for the model
    model.setData(data);
    // set the model to the core
    sap.ui.getCore().setModel(model);


### Binding Mode

### Context

CHANGE in VERSION 1.5.1 (MAY 2012): Databinding syntax changed, so that absolute bindings now must have a leading slash. For compatibility reasons, method `setLegacySyntax()` can be used to enable the old binding syntax.

Absolute path - with a leading slash

    var id = model.getProperty("/id");

Relative path - no leading slash and with a context instance:

    var context = new sap.ui.model.Context(model, "/users/0");
    var id = model.getProperty("id", context);

### Multimodel Support

### Binding Types

#### Property Binding

#### Aggregation Binding

#### Element Binding

### Data Types

### Validation

### Simple Types

* `sap.ui.model.type.Integer`
* `sap.ui.model.type.Float`
* `sap.ui.model.type.String`
* `sap.ui.model.type.Boolean`
* `sap.ui.model.type.Date`
* `sap.ui.model.type.Time`
* `sap.ui.model.type.DateTime`

### Data Types for Use Without Data Binding

* `sap.ui.core.format.DateFormat`
* `sap.ui.core.format.NumberFormat`

### Calculated Fields for Data Binding

#### Custom Formatter Functions

#### Extended Syntax for Calculated Fields

## Navigation

Navigation in SAPUI5 enables you to pass data from the hash to any view, and to adjust a current hash so that you can use it as a bookmarkable URL. Depending on the hash, you can also generate views automatically.

To notify your application that a hash has changed to a certain value, you use a route. If the route matches the hash, it provides the data that has been passed over to the hash to a defined handler.

    // Somewhere at the start of your application
    var routes = [
        {
            pattern: "product/{id}", // will be the url and from has to be provided in the data
            name: "specificProduct" // name used for listening or navigating to this route
        }
    ];

    var router = new sap.ui.core.routing.Router(routes);

    // this is used to retrieve the instance again
    router.register("appRouter");

    // starts reacting on the hashchange + parses the current hash and notifies callbacks
    router.initialize();


The following code snippet shows how you can register to this:

    sap.ui.controller("MyApp.View1", {
        // inside of a controller
        onInit: function() {
            var router = sap.ui.core.routing.Router.getRouter("appRouter");

            router.attachRouteMatched(function(event) {
                if (event.getParameter("name") !== "specificProduct") {
                    return; //we only want to react to events for the specificProductRoute
                }

                // We now know we hit the specificProduct route and retrieve the id
                this._selectItemWithId(event.getParameter("arguments").id);

                // bind the this pointer to the callback
            }, this);
        },

        _selectItemWithId: function(id) {
            //implementation eg: select an item in a list
        }


### Routing in UI Components

### Configuration Parameters for Navigation

### Methods and Events for Navigation

### Route Matching

### Building a Catchall Route

## Controls

### Control Implementation

#### Normal Methods

#### `init()` Method

#### Event Handler Methods

#### Renderer Methods

### Handling Events in Controls

### Control Renderer

### Custom Data

### Focus Handling

### Item Navigation - Supporting Keyboard Handling

### Right-to-Left Support in controls

## Declarative Support

## Application Structure

### Modularization and Dependency Management

### Resource Handling

#### Client-Side Mechanism

#### Server-Side Mechanism

#### Resource Servlet

    <!-- ============================================================== -->
    <!-- SAPUI5 resource servlet used to handle application resources   -->
    <!-- ============================================================== -->

    <servlet>
        <display-name>ResourceServlet</display-name>
        <servlet-name>ResourceServlet</servlet-name>
        <servlet-class>com.sap.ui5.resource.ResourceServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>ResourceServlet</servlet-name>
        <url-pattern>/resources/*</url-pattern>
    </servlet-mapping>
    <servlet-mapping>
        <servlet-name>ResourceServlet</servlet-name>
        <url-pattern>/test-resources/*</url-pattern>
    </servlet-mapping>

#### Configuration

The Resource Handler is configured via context parameter which are defined in the web.xml.

* `com.sap.ui5.resource.USE_CACHE` - flag to enable resource cache or not (default: "true")
* `com.sap.ui5.resource.MAX_AGE` - max age of resources in millis (default: "604800000" - 1 week)
* `com.sap.ui5.resource.ACCEPTED_ORIGINS` - list of accepted origins, e.g. \* or \*sap.corp,vesapui5.dhcp.wdf.sap.corp (default: empty)
* `com.sap.ui5.resource.DEV_MODE` - flag to enable the development mode (default: "false")
* `com.sap.ui5.resource.TEMPLATE_PATH` - template for the resource listing (default: "/templates/listing.html")
* `com.sap.ui5.resource.VERBOSE` - verbosity of the resource handler (default: "false")
* `com.sap.ui5.resource.REMOTE_LOCATION` - remote location which is used to proxy requests to for resources not being located locally (default: empty)
* `com.sap.ui5.resource.PREFER_REMOTE_LOCATION` - flag to prefer resolving the resource from the remote location before fallback to the classpath (default: false)

#### Development Mode

When starting to develop SAPUI5 controls and modules being located inside the servlet paths resources/ or test-resources/ it makes simplifies this development process by disabling the caching of such resources as well as enabling the resource browsing. To activate the development mode you need to add the following context parameter.

    <!-- BEGIN: DEV MODE -->
    <context-param>
        <param-name>com.sap.ui5.resource.DEV_MODE</param-name>
        <param-value>true</param-value>
    </context-param>
    <!-- END: DEV MODE -->

#### Tunneling a Remote Location

#### Resource Packaging

#### OSGi Servlet Container

### Cache Buster

A **Cache Buster** allows the application to notify the browser to refresh the resources only when the application resources have been changed. Otherwise the resources can always be fetched from the browser's cache.

### SAPUI5 Components

SAPUI5 provides the following two types of components:

* UI components (class: `sap.ui.core.UIComponent`)

UI components represent a screen area or element on the user interface, for example, a button or a shell, along with the respective settings and metadata.

* Faceless components (class: `sap.ui.core.Component`)

Faceless components do not have a user interface and are used, for example, for a service that delivers data from a back-end system.

#### Structure of a Component

A component is a folder. The folder name defines the component name and contains all optional and required resources that are used in the component except for the required SAPUI5 libraries and child components. Optional resources are, for example, the CSS and internationalization files, views, and images. The following files are mandatory for components:

* component.js

This is the component controller and provides the runtime metadata (properties, aggregation, events) and the component methods. The name parameter that is passed to the component constructor represents the package name under which you can find the component.

* component.json

This is the component descriptor and contains the design-time metadata; you need this file for design-time environments such as the AppDesigner. The file is not loaded during runtime.

The following gives an example of a component folder structure.

    |-- shell
        |-- css
            |-- shell.css
        |-- i18n
            |-- messagebundle.properties
            |-- messagebundle.properties.de
        |-- img
            |-- logo.png
        |-- js
            |-- shell.js
        |-- views
            |-- Products.controller.js
            |-- Products.view.xml
        |-- Component.js
        |-- component.json


## Localization

### Language Code / Locale

### Resource Bundles

* Java message bundle \*.properties
* Switch locales by setting different resource bundles.
* Cannot support parameters well.

### Use of Localized Texts in Applications

    var format = {style: "medium"}; // "short", "medium", "long", "full"
    var locale = new sap.ui.core.Locale("en-US");
    var dateFormat = sap.ui.core.format.DateFormat.getDateTimeInstance(format, locale);
    var str = dateFormat.format(new Date());

Date time formats in v1.8.7:

    || Format || en-US || en-GB || zh-CN || zh-TW ||
    | dateFormat-full | Tuesday, January 15, 2013 | Tuesday, 15 January 2013 | 2013年1月15日星期二 | 2013年1月15日星期二 |
    | dateFormat-long | January 15, 2013 | 15 January 2013 | 2013年1月15日 | 2013年1月15日 |
    | dateFormat-medium | Jan 15, 2013 | 15 Jan 2013 | 2013-1-15 | 2013/1/15 |
    | dateFormat-short | 1/15/13 | 15/01/2013 | 13-1-15 | 13/1/15 |
    | timeFormat-full | 7:09:08 PM GMT+08:00 | 19:09:08 GMT+08:00 | GMT+08:00下午7时09分08秒 | GMT+08:00下午7時09分08秒 |
    | timeFormat-long | 7:09:08 PM GMT+08:00 | 19:09:08 GMT+08:00 | GMT+08:00下午7时09分08秒 | GMT+08:00下午7時09分08秒 |
    | timeFormat-medium | 7:09:08 PM | 19:09:08 | 下午7:09:08 | 下午7:09:08 |
    | timeFormat-short | 7:09 PM | 19:09 | 下午7:09 | 下午7:09 |
    | dateTimeFormat-full | Tuesday, January 15, 2013 7:09:08 PM GMT+08:00 | Tuesday, 15 January 2013 19:09:08 GMT+08:00 | 2013年1月15日星期二GMT+08:00下午7时09分08秒 | 2013年1月15日星期二GMT+08:00下午7時09分08秒 |
    | dateTimeFormat-long | January 15, 2013 7:09:08 PM GMT+08:00 | 15 January 2013 19:09:08 GMT+08:00 | 2013年1月15日GMT+08:00下午7时09分08秒 | 2013年1月15日GMT+08:00下午7時09分08秒 |
    | dateTimeFormat-medium | Jan 15, 2013 7:09:08 PM | 15 Jan 2013 19:09:08 | 2013-1-15 下午7:09:08 | 2013/1/15 下午7:09:08 |
    | dateTimeFormat-short | 1/15/13 7:09 PM | 15/01/2013 19:09 | 13-1-15 下午7:09 | 13/1/15 下午7:09 |


## Extensibility

### View Extension

### View Modification

### View Replacement

### Controller Extension

### Controller Replacement

### I18n Resource Text Customization

### Supportability and Limitations


## Control Development

[File structure of SAPUI5 UI libraries](http://vesapui5.dhcp.wdf.sap.corp:1080/trac/sapui5/wiki/Documentation/AdvancedTopics/FileStructure)

The specific fold structure:

    src/main/uilib
        |-- <library-folder>
            |-- themes
                |-- base                // one 'theme' that can be loaded at runtime... base is mandatory
                    |-- library.css
                |-- sap_goldreflection
                    |-- library.css
                |-- sap_hcb
                    |-- library.css
            |-- library.js
            |-- shared.js               // containing 'shared' javascript like datatypes etc.
            |-- <Control>.js            // containing the control API and implementation
            |-- <Control>Renderer.js    // containing the renderer for the control
    src/test/uilib
        |-- test-resources
            |-- <libraryName>
                |-- <Control>.html


## Theming


## Security Information

## Troubleshooting

### Debugging

### Logging and Tracing

### SAPUI5 Diagnostics

## Coding Guidelines

* [JavaScript Coding Guidelines](http://vesapui5.dhcp.wdf.sap.corp:1080/trac/sapui5/wiki/InternalDocumentation/DevelopmentGuidelines/JavaScript)
* [Code Review Results](http://vesapui5.dhcp.wdf.sap.corp:1080/trac/sapui5/wiki/InternalDocumentation/DevelopmentGuidelines/CodeReviewResults)

### Naming Conventions for Control Artifacts

### Reserved Characters for Control IDs

### Reserved IDs for DOM Nodes and Elements

### Reserved DOM Attributes

### Reserved URL Parameters

### Control CSS


## Control API

### Layout

`layoutData` - LayoutData defining the layout constraints for this control when it is used inside a Layout.

#### sap.ui.layout.HorizontalLayout

A layout that provides support for horizontal alignment of controls.

    <layout:HorizontalLayout id="layout" allowWrapping="false">
        <TextView text="1"></TextView>
        <TextView text="2"></TextView>
    </layout:HorizontalLayout>


#### sap.ui.layout.VerticalLayout

In this layout the elements are ordered one below the other.

    <layout:VerticalLayout id="layout" width="100%" enabled="true">
        <TextView text="1"></TextView>
        <TextView text="2"></TextView>
    </layout:VerticalLayout>


#### sap.ui.layout.Grid

The Grid control is a layout which positions its child controls in a 12 column flow layout.

With this control it is possible to achieve flexible layouts and line-breaks for large-, medium- and small-sized screens, such as desktop, tablet, and mobile.

Layout - `sap.ui.layout.Grid`
* `hSpacing` - Horizontal spacing between the content in the Grid. In rem, can be 0, 1 or 2.
* `vSpacing` - Vertical spacing between the rows in the Grid. In rem, can be 0, 1 or 2.

LayoutData - `sap.ui.layout.GridData`
* `indent` - represents Grid's indent values for large, medium and small screens.
* `span` - represents Grid's span values for large, medium and small screens.

Example:

    <layout:Grid id="layout" hSpacing="1" vSpacing="1">
        <TextView text="Indent by 3 columns on large, 2 columns on medium, and 1 column on small screens.">
            <layoutData>
                <layout:GridData indent="L3 M2 S1" span="L2 M2 S2"></layout:GridData>
            </layoutData>
        </TextView>
        <TextView text="Indent by 1 column on large, 2 columns on medium, and 3 column on small screens.">
            <layoutData>
                <layout:GridData indent="L1 M2 S3" span="L2 M2 S2"></layout:GridData>
            </layoutData>
        </TextView>
    </layout:Grid>



#### sap.ui.layout.ResponsiveFlowLayout

With ResponsiveFlowLayout added content can be expanded to the full width of a row.

The default HTML behavior is that all items are positioned right next to each other. If the space within the parent container becomes too small, the browser wraps the corresponding item to the next line. In this case the space within a line isn't used.

With this layout each added content can be shrinked to a set min-width. So the layout shrinks it until this set value and wraps it if necessary. Each content within a line will be maximized to fit the whole line. Each content item can have a weight corresponding to other items within a line. If one item has the weight of '2' and all others have '1' so this single item will always be twice of all others.

* `responsive` - If this property is 'false' all added controls keep their widths. Otherwise all added controls will be extended to the possible width of a row.

LayoutData - `sap.ui.layout.ResponsiveFlowLayoutData`

A LayoutData instance can be added to a control that should be used within the ResponsiveFlowLayout. With this instance other values than the default values can be used.

Default values are:

* `minWidth`: 100 - that means that the min-width is used as "100px".
* `weight`: 1 - the weight of the added content item. A value smaller than 1 is not valid.
* `linebreak`: false - this content item won't be at the first position of a row. Otherwise this item will always be first in a line.
* `margin`: true - this property prevents any margin of the element if set to false.
* `linebreakable`: true - If this value is set to true, the element can be wrapped into a new line. If this value is set to false, the min-width will be set to 0 and the wrapping is up to the previous element.

In this case the Label and the TextField belong together. If the space becomes too less the TextField is wrapped below the Label. If the space is continuing shrinking, the part of the 'Last name' is wrapped below the 'First name' stuff.

    <layout:ResponsiveFlowLayout id="layout">

        <layout:ResponsiveFlowLayout id="innerFirst">
            <layout:layoutData>
                <layout:ResponsiveFlowLayoutData minWidth="250"></layout:ResponsiveFlowLayoutData>
            </layout:layoutData>

            <Label text="First name" width="100%"></Label>
            <TextField width="100%">
                <layoutData>
                    <layout:ResponsiveFlowLayoutData weight="2"></layout:ResponsiveFlowLayoutData>
                </layoutData>
            </TextField>
        </layout:ResponsiveFlowLayout>

        <layout:ResponsiveFlowLayout id="innerLast">
            <layout:layoutData>
                <layout:ResponsiveFlowLayoutData minWidth="250"></layout:ResponsiveFlowLayoutData>
            </layout:layoutData>

            <Label text="Last name" width="100%"></Label>
            <TextField width="100%">
                <layoutData>
                    <layout:ResponsiveFlowLayoutData weight="2"></layout:ResponsiveFlowLayoutData>
                </layoutData>
            </TextField>
        </layout:ResponsiveFlowLayout>

    </layout:ResponsiveFlowLayout>

### Form

#### sap.ui.layout.form.SimpleForm

Use the SimpleForm to create a form based on title, label and fields that are stacked in the content aggregation. Add Title to start a new FormContainer (Group). Add Label to start a new row in the container. Add Input/Display controls as needed. Use LayoutData to influence the layout for special cases in the Input/Display controls.

#### sap.ui.layout.form.GridLayout

The GridLayout can be attached to the Form Control in order to arrange the Elements in a cell based Layout.

To adjust the content inside the GridLayout GridContainerData and GridElementData could be used.

This layout implements a guideline 2.0 grid. this can be a 16 column grid or an 8 column grid.

The GridLayout is by default a 16 cells grid but you can set the `singleColumn` property to `true` in order to get an 8 cell grid. In this case you cannot include halfGrid Containers. Within the default Grid the FormContainers you can also place two containers in one row by setting `halfGrid` to `true` within the respective GridContainerData attached. The FormElements included can then have `hCells` and `vCells` set as GridElementData attached to the respective labels and fields in order to get the different arrangements within the grid. You can also add dummy FormElements in order to get some spare rows or dummy TextViews in order to get some spare cells.

* `singleColumn` - default `false`

Label is 3 cells by default. Field is 13 cells by default.

    <form:Form>
        <form:layout>
            <form:GridLayout singleColumn="false"></form:GridLayout>
        </form:layout>

        <form:FormContainer title="Legend">
            <form:layoutData>
                <form:GridContainerData halfGrid="false"></form:GridContainerData>
            </form:layoutData>

            <form:FormElement label="Email">
                <TextField name="email" placeholder="Email"></TextField>
            </form:FormElement>
            <form:FormElement label="Password">
                <PasswordField name="password" placeholder="Password"></PasswordField>
            </form:FormElement>
            <form:FormElement label="">
                <CheckBox name="checked" text="Checkbox"></CheckBox>
            </form:FormElement>
            <form:FormElement label="Radios">
                <RadioButtonGroup name="option">
                    <core:Item key="1" text="Option one is this"></core:Item>
                    <core:Item key="2" text="Option two can be something else"></core:Item>
                </RadioButtonGroup>
            </form:FormElement>
            <form:FormElement label="">
                <ListBox>
                    <core:ListItem key="1" text="Item 1"></core:ListItem>
                    <core:ListItem key="2" text="Item 2"></core:ListItem>
                    <core:ListItem key="3" text="Item 3"></core:ListItem>
                    <core:ListItem key="4" text="Item 4"></core:ListItem>
                    <core:ListItem key="5" text="Item 5"></core:ListItem>
                </ListBox>
            </form:FormElement>
            <form:FormElement label="">
                <Button text="Cancel">
                    <layoutData>
                        <form:GridElementData hCells="2"></form:GridElementData>
                    </layoutData>
                </Button>
                <Button text="Submit" style="Emph">
                    <layoutData>
                        <form:GridElementData hCells="2"></form:GridElementData>
                    </layoutData>
                </Button>
            </form:FormElement>
        </form:FormContainer>
    </form:Form>

#### sap.ui.layout.form.ResponsiveLayout

Render a form with responsive layout. Internally the ResponsiveFlowLayout is used.

You can use `ResponsiveFlowLayoutData` on FormContainers, FormElements and the content controls like in the ResponsiveFlowLayout control. so it is possible to influence the linebreaks, min width and weights of the single elements. If you use `ResponsiveFlowLayoutData` on Containers or Elements you should disable the margins to avoid nested margins. If `ResponsiveFlowLayoutData` are used, the margins are disabled by default.


    <form:Form>
        <form:layout>
            <form:ResponsiveLayout></form:ResponsiveLayout>
        </form:layout>

        <form:FormContainer title="Legend">
            <form:FormElement label="Email">
                <TextField name="email" placeholder="Email"></TextField>
            </form:FormElement>
            <form:FormElement label="Password">
                <form:layoutData>
                    <layout:ResponsiveFlowLayoutData linebreak="true" margin="false"></layout:ResponsiveFlowLayoutData>
                </form:layoutData>
                <PasswordField name="password" placeholder="Password"></PasswordField>
            </form:FormElement>
        </form:FormContainer>

        <form:FormContainer title="Legend 2">
            <form:FormElement label="">
                <CheckBox name="checked" text="Checkbox"></CheckBox>
            </form:FormElement>
            <form:FormElement label="Radios">
                <RadioButtonGroup name="option">
                    <layoutData>
                        <layout:ResponsiveFlowLayoutData weight="2"></layout:ResponsiveFlowLayoutData>
                    </layoutData>
                    <core:Item key="1" text="Option one is this"></core:Item>
                    <core:Item key="2" text="Option two can be something else"></core:Item>
                </RadioButtonGroup>
            </form:FormElement>
            <form:FormElement label="">
                <Button text="Cancel">
                    <layoutData>
                        <layout:ResponsiveFlowLayoutData weight="1"></layout:ResponsiveFlowLayoutData>
                    </layoutData>
                </Button>
                <Button text="Submit" style="Emph">
                    <layoutData>
                        <layout:ResponsiveFlowLayoutData weight="1"></layout:ResponsiveFlowLayoutData>
                    </layoutData>
                </Button>
            </form:FormElement>
        </form:FormContainer>
    </form:Form>


#### sap.ui.layout.form.ResponsiveGridLayout

Render a form using a grid. Internally the Grid is used. On the FormContainers, Labels and Fields GridData can be used to change the default rendering. On FormElements GridData are not supported. If own GridData are used this may be much more complex than the default. So in some cases the calculation for the other content may nor bring the expected result. In this case GridData should be used at all content to disable the default behavior.

You can use `GridData` on FormContainers and the content controls like in the Grid control. On FormElements `GridData` are not supported. To influence the rendering of the labels and fields `GridData` must be set on these controls. If no `GridData` are used on a FormContainer or Control, the `ResponsiveGridLayout` tries to calculate the linebreaks and spans.

    <form:Form>
        <form:layout>
            <form:ResponsiveGridLayout></form:ResponsiveGridLayout>
        </form:layout>

        <form:FormContainer title="Legend">
            <form:FormElement label="Email">
                <TextField name="email" placeholder="Email"></TextField>
            </form:FormElement>
            <form:FormElement label="Password">
                <PasswordField name="password" placeholder="Password"></PasswordField>
            </form:FormElement>
        </form:FormContainer>

        <form:FormContainer title="Legend 2">
            <form:FormElement label="">
                <CheckBox name="checked" text="Checkbox"></CheckBox>
            </form:FormElement>
            <form:FormElement label="Radios">
                <RadioButtonGroup name="option">
                    <layoutData>
                        <layout:GridData span="L2 M2 S12"></layout:GridData>
                    </layoutData>
                    <core:Item key="1" text="Option one is this"></core:Item>
                    <core:Item key="2" text="Option two can be something else"></core:Item>
                </RadioButtonGroup>
            </form:FormElement>
            <form:FormElement label="">
                <Button text="Cancel">
                    <layoutData>
                        <layout:GridData span="L2 M2 S6"></layout:GridData>
                    </layoutData>
                </Button>
                <Button text="Submit" style="Emph">
                    <layoutData>
                        <layout:GridData span="L2 M2 S6"></layout:GridData>
                    </layoutData>
                </Button>
            </form:FormElement>
        </form:FormContainer>
    </form:Form>




## Popup

### Hide in XML view


### DOM location

sap.ui.core.Popup - popups are placed in a static area.

    var core = sap.ui.core.getCore();
    var staticAreaRef = core.getStaticAreaRef();
    var $staticArea = jQuery(staticAreaRef);
    var $popups = $staticArea.children("class~=['sapUiUx3TP']");

### Dock, Position


## Testing

[Testing Environment](http://vesapui5.dhcp.wdf.sap.corp:1080/trac/sapui5/wiki/InternalDocumentation/TestingEnvironment)

### Selenium

[UI5 Control Wrapper for Selenium Application Testing](http://vesapui5.dhcp.wdf.sap.corp:1080/trac/sapui5/wiki/InternalDocumentation/TestingEnvironment/SeleniumWrapper)

[Selenium WebDriver Automation Framework](https://wiki.wdf.sap.corp/wiki/display/ECFQE/Selenium+WebDriver+Automation+Framework)

### QUnit

[How to Setup QUnit](http://vesapui5.dhcp.wdf.sap.corp:1080/trac/sapui5/wiki/InternalDocumentation/TestingEnvironment/HowToSetupQUnit)

UI5 implemented a bridge JSUnit to QUnit which is responsible to collect the status information of the QUnit tests and report them back into the JSUnit framework.

[QUnit Testing](http://vesapui5.dhcp.wdf.sap.corp:1080/trac/sapui5/wiki/Documentation/AdvancedTopics/QUnit)

#### Why does UI5 use Qunit tests?

QUnit tests have been proven to provide a much better support for asynchronous testing in comparision to JSUnit. These kind of tests are often needed for UI functional tests (e.g. wait until rendering is done, some animations complete or a backend call returns) but are complicated to create via JSUnit and are error-prone.

A QUnit test page can be executed standalone in the browser without the need of an additional "tool" like the JSUnit Testrunner. This eases the creation and execution of single QUnit tests.

Finally QUnit is closely related to jQuery (which is also included in UI5).

#### Why does UI5 use JSUnit Testrunner?

The JSUnit Testrunner can be easily integrated into the Maven build (Lean DI) environment to execute our JavaScript unit tests each build. The result of the Testrunner execution finally creates a report in the Maven surefire format which can be used for reporting purposes of a Hudson build server or a Sonar quality system or at least cause a Maven build to break. Also the JSUnit Testrunner is not using any JS shell (e.g. like Jasmine which is using Rhino) furthermore it opens a browser as a process with a parameter containing the site to load and finally waits until the browser submits the results to the Testrunner server. Another interesting usage of the JSUnit Testrunner is that you can cluster your tests in testsuites.

[How To Write A QUnit Test](http://vesapui5.dhcp.wdf.sap.corp:1080/trac/sapui5/wiki/InternalDocumentation/TestingEnvironment/QUnitHowToWriteQUnitTest)

### Build Integration

Inside the POM we use the antrunner plugin to execute the JSUnit TestRunner but beforehand we deploy the jsunit-tests and the jsunit-testrunner war files into a Jetty container. Afterwards it opens a browser with a specific URL and waits until the test has been executed and the result has been submitted to JSUnit server. Now the result will be converted into the Maven surefire format (JUnit). This result can be used e.g. in the Hudson build and display.
